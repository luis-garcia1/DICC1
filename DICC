#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<stdbool.h>

#define vacio -1
#define N 50

typedef struct entidad
{
	char nom[N];
	long listDatos;
	long ListAtributos;
	long sig;
}Entidades;//TNodo
typedef struct Atribute
{
	char name[50];
	bool isPrimary;
	long type;
	long size;//atibuto
	long nextAtribute;
}ATTRIBUTE;

void menu();
void EntidadesMenu(char diccionario[N]);
void imprimir(FILE *Diccionario);
void imprimirDatos(FILE *Diccionario,long LDatos,long LAtributos);
long AgregarEntidad(FILE *Diccionario,Entidades nuevaEntidad);
void OrdenarEntidad(FILE *Diccionario,long EntidadActual,const char* nuevoNombreEntidad,long nuevaDirEntidad);
int elimina(FILE *Diccionario, char nom[N]);
Entidades findEntity(FILE* dataDictionary,char entityName[50]);
void modificarEntidad(FILE* Diccionario,char nom[50]);
void insertarDatos(FILE *Diccionario, Entidades entidad);
void AgregarDato(FILE *Diccionario,long nuevoDato,long LDatos,long LAtributos);
void menuAtributos(char *diccionario, Entidades entidad);
void imprimirAtributos(FILE *Diccionario, long ListAtributos);
void CreateAttribute(FILE* dataDictionary, Entidades currentEntity);
long appendAttribute(FILE* dataDictionary, ATTRIBUTE newAttribute);
void reorderAttributes(FILE* dataDictionary, long currentAttributePointer, const char* newAttributeName, long newAttributeDirection, bool clavePrim);
int eliminaAtributo(FILE *Diccionario, char nom[N], long cab);
void modificaAtributo(FILE* dataDictionary,char nom[50], long cab);

int main () 
{
	menu();
}
void menu()
{
	FILE *diccionario;
	int ops; 
	long num= vacio;
	char nom[N];

	printf("----------MENU----------\n");
	printf("1-CREAR DICCIONARIO\n2-ABRIR DICCIONARIO\n3-SALIR\nOPCIÓN: ");
	scanf("%d",&ops);
	switch(ops)
	{
	case 1: printf("NOMBRE DEL DICCIONARIO: ");
			scanf("%s",nom);
			if(!(diccionario= fopen(nom,"wb")))
			{
				printf("ARCHIVO NO ENCONTRADO\n");
				menu();
			}
			else
				//inisialisar diccionario
				fwrite(&num, sizeof(long), 1, diccionario);
		break;
	case 2: printf("NOMBRE DEL DICCIONARIO: ");
			scanf("%s",nom);
			if(!(diccionario= fopen(nom,"rb+")))
			{
				printf("ARCHIVO NO ENCONTRADO\n");
				menu();
			}
		break;
	case 3: printf("PROGRAMA NO ENCONTRADO");
			exit(0);
		break;
	default: menu();
			break;
	}
	fclose(diccionario);
	EntidadesMenu(nom);
}

void EntidadesMenu(char diccionario[N])
{
	FILE *Diccionario= fopen(diccionario,"rb+");
	int ops;
	long DirEntidad;
	char nom[N];
	Entidades nuevaEntidad, entidad;
	
	
	printf("----------ENTIDADES----------\n");
	printf("1-IMPRIMIR\n2-NUEVA ENTIDAD\n3-ELIMINAR ENTIDAD\n4-MODIFICAR ENTIDAD\n5-SELECCIONAR ENTIDAD\n6-AGREGAR DATOS\n7-SALIR\n\nOPCIÓN: ");
	scanf("%d", &ops);
	switch(ops)
	{
	case 1: imprimir(Diccionario);
		break;
	case 2: printf("NOMBRE: ");
			scanf("%s",nuevaEntidad.nom);
			nuevaEntidad.ListAtributos= vacio;
			nuevaEntidad.listDatos= vacio;
			nuevaEntidad.sig= vacio;
			//Agregar entidad al final del archibo y guardar su posision
			DirEntidad= AgregarEntidad(Diccionario,nuevaEntidad);
			//Ordenar la entidad agregada
			OrdenarEntidad(Diccionario,0,nuevaEntidad.nom,DirEntidad);
			
		break;
	case 3: printf("NOMBRE: ");
			scanf("%s",nom);
			if(elimina(Diccionario,nom))
				printf("ELIMINADA\n");
			else
				printf("NO SE PUDO ELIMINAR\n");
		break;
	case 4: printf("NOMBRE: ");
			scanf("%s",nom);
			modificarEntidad(Diccionario,nom);
		break;
	case 5: rewind(Diccionario);
			printf("NOMBRE DE LA ENTIDAD: ");
			scanf("%s",nom);
			entidad= findEntity(Diccionario,nom);
			if(entidad.sig == 0)
			{
				printf("NO SE ENCONTRÓ ENTIDAD\n");
				fclose(Diccionario);
				EntidadesMenu(diccionario);
			}
			fseek(Diccionario,entidad.listDatos,SEEK_SET);
			fread(&DirEntidad,sizeof(long),1,Diccionario);
			if(DirEntidad != vacio)
			{
				printf("YA EXISTEN DATOS EN ESTA ENTIDAD, NO PUEDES MODIFICAR LSO ATRIBUTOS\n");
				fclose(Diccionario);
				EntidadesMenu(diccionario);
			}
			fclose(Diccionario);
			menuAtributos(diccionario,entidad);
		break;
	case 6: rewind(Diccionario);
			printf("NOMBRE DE LA ENTIDAD A MODIFICAR: ");
			scanf("%s",nom);
			entidad= findEntity(Diccionario,nom);
			if(entidad.sig == 0)
			{
				printf("NO SE ENCONTRÓ LA ENTIDAD\n");
				fclose(Diccionario);
				EntidadesMenu(diccionario);
			}
			insertarDatos(Diccionario,entidad);
		break;
	case 7: fclose(Diccionario);
			menu();
		break;
	}
	fclose(Diccionario);
	EntidadesMenu(diccionario);
}

void imprimir(FILE *Diccionario)
{
	
	Entidades Entidad;
	long direccion;
	
	rewind(Diccionario);
	fread(&direccion, sizeof(long),1,Diccionario);
	if(direccion == -1)
		printf("NO EXISTEN ENTIDADES\n");
	else
	  while(direccion != -1)
	  {
		fseek(Diccionario,direccion,SEEK_SET);
		
		fread(&Entidad.nom,N,1,Diccionario);
		fread(&Entidad.listDatos,sizeof(long),1,Diccionario);
		fread(&Entidad.ListAtributos,sizeof(long),1,Diccionario);
		fread(&direccion,sizeof(long),1,Diccionario);
		printf("\n--%s--\n ",Entidad.nom);
		
		//imprimirAtributos(Diccionario,Entidad.ListAtributos);
		ATTRIBUTE atributo;
		long direccion2;
		
		printf("-ATRIBUTOS\n");
		if(Entidad.ListAtributos == -1)
			printf("NO EXISTEN ATRIBUTOS\n");
		else
		{
			direccion2= Entidad.ListAtributos;
			while(direccion2 != -1)
			{
			fseek(Diccionario,direccion2,SEEK_SET);
			
			fread(&atributo.name,N,1,Diccionario);
			fread(&atributo.isPrimary,sizeof(bool),1,Diccionario);
			fread(&atributo.type,sizeof(long),1,Diccionario);
			fread(&atributo.size,sizeof(long),1,Diccionario);
			fread(&direccion2,sizeof(long),1,Diccionario);
			printf("  +%s\n",atributo.name);
			}
			printf("\n");
			if(Entidad.listDatos == vacio)
				printf("NO HAY DATOS\n");
			else
				imprimirDatos(Diccionario,Entidad.listDatos,Entidad.ListAtributos);
		}	
	  }
	printf("\n");
}
void imprimirDatos(FILE *Diccionario,long LDatos,long LAtributos)
{
	long ListAtributos,sig;
	int datoint;
	bool datobool;
	long datolong;
	float datofloat;
	char datochar[N];
	
	ATTRIBUTE atributo;
	
	sig= LDatos;
	
	if(sig == vacio)
	{
		printf("NO HAY DATOS\n");
	}
	else
	{
		while(sig != vacio)
		{
			ListAtributos= LAtributos;
			LDatos= sig;
			while(ListAtributos != -1)
			{
				//Moverse asia la lista de atributos
				fseek(Diccionario,ListAtributos,SEEK_SET);
				//Leer atributo
				fread(atributo.name, N, 1, Diccionario);
				fread(&atributo.isPrimary, sizeof(bool), 1, Diccionario);
				fread(&atributo.type, sizeof(long), 1, Diccionario);
				fread(&atributo.size, sizeof(long), 1, Diccionario);
				//apuntador al siguiente atributo
				fread(&ListAtributos, sizeof(long), 1, Diccionario);
				
				//moverse al dato
				fseek(Diccionario,LDatos,SEEK_SET);
				switch(atributo.type)
				{
				case 1: fread(&datoint,sizeof(int),1,Diccionario);
						printf("|%d",datoint);
				break;
				case 2: fread(&datolong,sizeof(long),1,Diccionario);
						printf("|%li",datolong);
				break;
				case 3: fread(&datofloat,sizeof(float),1,Diccionario);
						printf("|%.2f",datofloat);
				break;
				case 4: fread(&datochar,sizeof(char),N,Diccionario);
						printf("|%s",datochar);
				break;
				case 5: fread(&datobool,sizeof(bool),1,Diccionario);
						if(datobool)
							printf("|VERDADERO");
						else
							printf("|FALSO");
				break;
				}
				LDatos= ftell(Diccionario);
			}
			fread(&sig,sizeof(long),1,Diccionario);
			printf("\n");
		}
	}
}

long AgregarEntidad(FILE *Diccionario,Entidades nuevaEntidad)
{
	fseek(Diccionario,0,SEEK_END);
	//esta es la dirección de la nueva Entidad
	long DirEntidad = ftell(Diccionario);
	fwrite(nuevaEntidad.nom, 50, 1, Diccionario);
	fwrite(&nuevaEntidad.listDatos, sizeof(long), 1, Diccionario);
	fwrite(&nuevaEntidad.ListAtributos, sizeof(long), 1, Diccionario);
	fwrite(&nuevaEntidad.sig, sizeof(long), 1, Diccionario);
	return DirEntidad;
}
void OrdenarEntidad(FILE *Diccionario,long EntidadActual,const char* nuevoNombreEntidad,long nuevaDirEntidad)
{
	long DirEntidad=-1;
	
	fseek(Diccionario,EntidadActual,SEEK_SET);
	fread(&DirEntidad,sizeof(DirEntidad),1,Diccionario);
	
	if(DirEntidad == -1L)
	{
		//No hay más entidades para iterar. Establezca el puntero actual en la nueva dirección de la entidad
		fseek(Diccionario,EntidadActual, SEEK_SET);
		fwrite(&nuevaDirEntidad,sizeof(long),1,Diccionario);
	}
	else{
		char currentEntityName[50];
		//long nextEntityDirection;
		long nextHeaderPointer;
		
		//Vaya a la ubicación de la entidad y lea sus datos
		fseek(Diccionario,DirEntidad,SEEK_SET);
		//Lea el nombre de la entidad en la posición actual
		fread(&currentEntityName,sizeof(char),50,Diccionario);
		nextHeaderPointer= ftell(Diccionario) + (sizeof(long) * 2);
		//Compare los nombres de las entidades para determinar si la entidad actual debe estar antes de la nueva o no
		if(strcmp(currentEntityName, nuevoNombreEntidad) < 0){
			//La entidad actual es anterior a la nueva
			OrdenarEntidad(Diccionario,nextHeaderPointer,nuevoNombreEntidad,nuevaDirEntidad);
		}
		else
		{
			if(strcmp(currentEntityName, nuevoNombreEntidad) == 0)
			{
				printf("YA EXISTE ESA ENTIDAD\n");
			}
			else{
			//Reasignar el primer puntero
			fseek(Diccionario,EntidadActual,SEEK_SET);
			fwrite(&nuevaDirEntidad, sizeof(long),1,Diccionario);
			// Reassign new entity pointer
			fseek(Diccionario,nuevaDirEntidad + 50 + (sizeof(long) * 2),SEEK_SET);
			fwrite(&DirEntidad, sizeof(long),1,Diccionario);
			}
		}
	}
	
}

int elimina(FILE *Diccionario, char nom[N]) {
	
	rewind(Diccionario);
	if (!Diccionario) 
		return 0;
	
	Entidades entidad;
	long ant, ptr, ptrdir;
	
	// Leer la cabecera (dirección de la cabeza de la lista)
	fread(&ptr, sizeof(long), 1, Diccionario);
	if (ptr == -1) {
		return 0; // Lista vacía
	}
	
	// Desplazarse a la primera entidad
	fseek(Diccionario, ptr, SEEK_SET);
	fread(entidad.nom, N, 1, Diccionario);
	fread(&entidad.listDatos, sizeof(long), 1, Diccionario);
	fread(&entidad.ListAtributos, sizeof(long), 1, Diccionario);
	ptrdir = ftell(Diccionario); // Dirección de la primera entidad
	fread(&ptr, sizeof(long), 1, Diccionario); // Obtener el puntero 'sig' de la primera entidad
	
	// Si la entidad a eliminar es la primera (cabeza de la lista)
	if (strcmp(entidad.nom, nom) == 0) {
		// Actualizamos la cabeza de la lista para que apunte a la siguiente entidad
		rewind(Diccionario);
		fwrite(&ptr, sizeof(long), 1, Diccionario); // Nueva cabeza de la lista
		
		return 1; // Eliminada con éxito
	}
	
	// Buscar la entidad a eliminar en el resto de la lista
	while (ptr != -1 && strcmp(entidad.nom, nom) != 0) {
		ant = ptrdir;
		fseek(Diccionario, ptr, SEEK_SET); // Desplazarse a la entidad actual
		fread(entidad.nom, N, 1, Diccionario);
		fread(&entidad.listDatos, sizeof(long), 1, Diccionario);
		fread(&entidad.ListAtributos, sizeof(long), 1, Diccionario);
		ptrdir = ftell(Diccionario); // Dirección de la entidad actual
		fread(&ptr, sizeof(long), 1, Diccionario); // Leer el siguiente puntero
	}
	
	// Si no se encontró la entidad, devolvemos 0
	if (ptr == -1 && strcmp(entidad.nom, nom) != 0)
		return 0;
	
	// Ahora eliminamos la entidad: Actualizamos el puntero 'sig' de la entidad anterior
	fseek(Diccionario, ant, SEEK_SET); // Desplazarse a la entidad anterior
	fwrite(&ptr, sizeof(long), 1, Diccionario); // Actualizamos el puntero 'sig' para omitir la entidad eliminada
	
	return 1; // Eliminación exitosa
}

Entidades findEntity(FILE* dataDictionary,char entityName[50])
{
	Entidades currentEntity,aux;
	
	rewind(dataDictionary);
	//leer cabesera
	fread(&aux.sig,sizeof(long),1,dataDictionary);
	//moverse a la primera entidad
	fseek(dataDictionary,aux.sig, SEEK_SET);
	//leer direccion y datos de la primera entidad
	fread(&currentEntity.nom,sizeof(char),50,dataDictionary);
	currentEntity.listDatos= ftell(dataDictionary);
	fread(&aux.listDatos,sizeof(long),1,dataDictionary);
	currentEntity.ListAtributos= ftell(dataDictionary);
	fread(&aux.ListAtributos,sizeof(long),1,dataDictionary);
	currentEntity.sig= ftell(dataDictionary);
	fread(&aux.sig,sizeof(long),1,dataDictionary);
	
	while (aux.sig != -1 && (strcmp(currentEntity.nom,entityName)) != 0)
	{
		//mover a la siguiente entidad
		fseek(dataDictionary,aux.sig, SEEK_SET);
		//leer direccion y datos de la primera entidad
		fread(&currentEntity.nom,sizeof(char),50,dataDictionary);
		currentEntity.listDatos= ftell(dataDictionary);
		fread(&aux.listDatos,sizeof(long),1,dataDictionary);
		currentEntity.ListAtributos= ftell(dataDictionary);
		fread(&aux.ListAtributos,sizeof(long),1,dataDictionary);
		currentEntity.sig= ftell(dataDictionary);
		fread(&aux.sig,sizeof(long),1,dataDictionary);
	}
	
	if(aux.sig == -1 && (strcmp(currentEntity.nom,entityName)) != 0)
		   currentEntity.sig= 0;
	
	return currentEntity;
	
}

void modificarEntidad(FILE* Diccionario,char nom[50])
{
	rewind(Diccionario);
	long DirEntidad;
	Entidades ptr,nuevaEntidad,aux;
	
	//buscar el nodo
	ptr= findEntity(Diccionario,nom);
	if(ptr.sig == 0)
	{
		printf("LA ENTIDAD NO EXISTE\n");
		return;
	}
	
	//eliminar entidad
	elimina(Diccionario,nom);
	
	printf("NUEVO NOMBRE: ");
	scanf("%s",nuevaEntidad.nom);
	fseek(Diccionario,ptr.listDatos,SEEK_SET);
	fread(&nuevaEntidad.listDatos,sizeof(long),1,Diccionario);
	fread(&nuevaEntidad.ListAtributos,sizeof(long),1,Diccionario);
	nuevaEntidad.sig= vacio;
	
	aux= findEntity(Diccionario,nuevaEntidad.nom);
	while(aux.sig != 0)
	{
		if(aux.sig != 0)
			printf("ESE NOMBRE YA ESTA EN USO\n");
		printf("NUEVO NOMBRE: ");
		scanf("%s",nuevaEntidad.nom);
		aux= findEntity(Diccionario,nuevaEntidad.nom);
	}
	

	
	DirEntidad= AgregarEntidad(Diccionario,nuevaEntidad);
	
	OrdenarEntidad(Diccionario,0,nuevaEntidad.nom,DirEntidad);
	printf("MODIFICADO\n");
}



void insertarDatos(FILE *Diccionario, Entidades entidad)
{
	long LDatos,LAtributos,ListAtributos,sig,nuevoDato,pos;
	int datoint;
	bool datobool;
	long datoLong;
	float datofloat;
	char datochar[N];

	ATTRIBUTE atributo;
	
	fseek(Diccionario,0,SEEK_END);
	nuevoDato= ftell(Diccionario);
	
	
	fseek(Diccionario,entidad.listDatos,SEEK_SET);
	fread(&LDatos,sizeof(long),1,Diccionario);
	fread(&LAtributos,sizeof(long),1,Diccionario);
	ListAtributos= LAtributos;
	if(ListAtributos == vacio)
	{
		printf("NO EXISTEN ATRIBUTOS\n");
		return;
	}
	
	while(ListAtributos != -1)
	{
		//Moverse asia la lista de atributos
		fseek(Diccionario,ListAtributos,SEEK_SET);
		//Leer atributo
		fread(atributo.name, N, 1, Diccionario);
		fread(&atributo.isPrimary, sizeof(bool), 1, Diccionario);
		fread(&atributo.type, sizeof(long), 1, Diccionario);
		fread(&atributo.size, sizeof(long), 1, Diccionario);
		//apuntador al siguiente atributo
		fread(&ListAtributos, sizeof(long), 1, Diccionario);
		
		printf("%s: ",atributo.name);
		switch(atributo.type)
		{
			case 1: scanf(" %d",&datoint);
				fseek(Diccionario,0,SEEK_END);
				fwrite(&datoint,sizeof(int),1,Diccionario);
				break;
			case 2: scanf(" %li",&datoLong);
				fseek(Diccionario,0,SEEK_END);
				fwrite(&datoLong,sizeof(long),1,Diccionario);
				break;
			case 3: scanf(" %f",&datofloat);
				fseek(Diccionario,0,SEEK_END);
				fwrite(&datofloat,atributo.size,1,Diccionario);
				break;
			case 4: scanf(" %s",datochar);
				fseek(Diccionario,0,SEEK_END);
				fwrite(&datochar,sizeof(char),N,Diccionario);
				break;
			case 5: 
				do
				{
					printf("\n1-VERDADERO\n0-FALSO\nOPCIÓN: ");
					scanf(" %d",&datoint);
				} while(datoint<0 || datoint>1);
				datobool= datoint;
				fseek(Diccionario,0,SEEK_END);
				fwrite(&datobool,sizeof(bool),1,Diccionario);
				break;
		}
		pos= ftell(Diccionario);
		printf("POS: %li\n",pos);
	}
	sig= vacio;
	fwrite(&sig,sizeof(long),1,Diccionario);
	AgregarDato(Diccionario,nuevoDato,entidad.listDatos,LAtributos);
}
void AgregarDato(FILE *Diccionario,long nuevoDato,long LDatos,long LAtributos)
{
	long ListAtributos,sig,fin;
	int datoint;
	bool datobool;
	long datoLong;
	float datofloat;
	char datochar[N];
	
	ATTRIBUTE atributo;
	
	fseek(Diccionario,LDatos,SEEK_SET);
	fread(&sig,sizeof(long),1,Diccionario);
	
	if(sig == vacio)
	{
		fseek(Diccionario,LDatos,SEEK_SET);
		fwrite(&nuevoDato,sizeof(long),1,Diccionario);
	}
	else
	{
		while(sig != vacio)
		{
			ListAtributos= LAtributos;
		while(ListAtributos != -1)
		{
			//Moverse asia la lista de atributos
			fseek(Diccionario,ListAtributos,SEEK_SET);
			//Leer atributo
			fread(atributo.name, N, 1, Diccionario);
			fread(&atributo.isPrimary, sizeof(bool), 1, Diccionario);
			fread(&atributo.type, sizeof(long), 1, Diccionario);
			fread(&atributo.size, sizeof(long), 1, Diccionario);
			//apuntador al siguiente atributo
			fread(&ListAtributos, sizeof(long), 1, Diccionario);
			
			//moverse al dato
			fseek(Diccionario,sig,SEEK_SET);
			switch(atributo.type)
			{
			case 1: fread(&datoint,sizeof(int),1,Diccionario);
					sig= ftell(Diccionario);
			break;
			case 2: fread(&datoLong,sizeof(long),1,Diccionario);
					sig= ftell(Diccionario);
			break;
			case 3: fread(&datofloat,sizeof(float),1,Diccionario);
					sig= ftell(Diccionario);
			break;
			case 4: fread(&datochar,sizeof(char),N,Diccionario);
					sig= ftell(Diccionario);
			break;
			case 5: fread(&datobool,sizeof(bool),1,Diccionario);
					sig= ftell(Diccionario);
			break;
			}
		}
		fin= ftell(Diccionario);
		fread(&sig,sizeof(long),1,Diccionario);
		}
		//cuando llege al final escribir el siguiente
		fseek(Diccionario,fin,SEEK_SET);
		fwrite(&nuevoDato,sizeof(long),1,Diccionario);
	}
}

void menuAtributos(char *diccionario, Entidades entidad)
{
	FILE *Diccionario= fopen(diccionario,"rb+");
	int ops;
	char nom[N];
	
	printf("----------ATRIBUTOS %s----------\n",entidad.nom);
	printf("1-IMPRIMIR ATRIBUTOS\n2-NUEVO ATRIBUTO\n3-ELIMINAR ATRIBUTO\n4-MODIFICAR ATRIBUTO\n5-SALIR\nOPCIÓN: ");
	scanf("%d",&ops);
	
	switch(ops)
	{
	case 1: printf("--%s--\n",entidad.nom);
			imprimirAtributos(Diccionario,entidad.ListAtributos);
		break;
	case 2: CreateAttribute(Diccionario,entidad);
		break;
	case 3: printf("NOMBRE: ");
			scanf("%s",nom);
			if(eliminaAtributo(Diccionario,nom,entidad.ListAtributos))
				printf("ELIMINADO\n");
			else
				printf("ELIMINACIÓN FALLIDA\n");
		break;
	case 4: printf("NOMBRE: ");
			scanf("%s",nom);
			modificaAtributo(Diccionario,nom,entidad.ListAtributos);
		break;
	case 5: fclose(Diccionario);
			EntidadesMenu(diccionario);
		break;
	}
	
	fclose(Diccionario);
	menuAtributos(diccionario,entidad);
}

void imprimirAtributos(FILE *Diccionario, long ListAtributos)
{
	ATTRIBUTE atributo;
	long direccion;
	
	printf("-ATRIBUTOS\n");
	fseek(Diccionario,ListAtributos,SEEK_SET);
	fread(&direccion, sizeof(long),1,Diccionario);
	if(direccion == -1 || ListAtributos == -1)
		printf("  NO HAY ATRIBUTOS\n");
	else
		while(direccion != -1)
		{
		fseek(Diccionario,direccion,SEEK_SET);
		
		fread(&atributo.name,N,1,Diccionario);
		fread(&atributo.isPrimary,sizeof(bool),1,Diccionario);
		fread(&atributo.type,sizeof(long),1,Diccionario);
		fread(&atributo.size,sizeof(long),1,Diccionario);
		fread(&direccion,sizeof(long),1,Diccionario);
		printf("  -%s\n",atributo.name);
		}	
}

void CreateAttribute(FILE* dataDictionary, Entidades currentEntity)
{
	ATTRIBUTE newAttribute;
	int tamano, aux;
	
	printf("\nNOMBRE DEL NUEVO ATRIBUTO: ");
	
	scanf("%s",newAttribute.name);
	
	printf("ES UNA CLAVE PRIMARIA? 1-SI 0-NO : ");
	scanf("%d",&aux);
	newAttribute.isPrimary= aux;
	
	printf("TIPO DE ATRIBUTO? 1-INT 2-LONG 3-FLOAT 4-CHAT 5-BOOL : ");
	scanf("%d",&aux);
	newAttribute.type= aux;
	
	switch(newAttribute.type)
	{
	case 1: newAttribute.size= sizeof(int);
	break;
	
	case 2: newAttribute.size= sizeof(long);
	break;
	
	case 3: newAttribute.size= sizeof(float);
	break;
	
	case 4: printf("TAMAÑO: ");
	scanf("%d",&tamano);
	newAttribute.size= sizeof(char) * tamano;
	break;
	
	case 5: newAttribute.size= sizeof(bool);
	break;
	}
	
	newAttribute.nextAtribute= vacio;
	
	long attributeDirection= appendAttribute(dataDictionary,newAttribute);
	reorderAttributes(dataDictionary,currentEntity.ListAtributos,newAttribute.name,attributeDirection,newAttribute.isPrimary);
}

long appendAttribute(FILE* dataDictionary, ATTRIBUTE newAttribute){
	
	fseek(dataDictionary,0,SEEK_END);
	//Esta es la dirección de la nueva Entidad
	long entityDirection= ftell(dataDictionary);
	
	fwrite(newAttribute.name, 50, 1, dataDictionary);
	fwrite(&newAttribute.isPrimary, sizeof(bool), 1, dataDictionary);
	fwrite(&newAttribute.type, sizeof(long), 1, dataDictionary);
	fwrite(&newAttribute.size, sizeof(long), 1, dataDictionary);
	fwrite(&newAttribute.nextAtribute, sizeof(long), 1, dataDictionary);
	
	return entityDirection;
}

void reorderAttributes(FILE* dataDictionary, long currentAttributePointer, const char* newAttributeName, long newAttributeDirection, bool clavePrim)
{
	long currentAttributeDirection= -1;
	fseek(dataDictionary,currentAttributePointer,SEEK_SET);
	fread(&currentAttributeDirection,sizeof(currentAttributeDirection),1,dataDictionary);
	if(currentAttributeDirection == -1){
		//No hay más entidades para iterar. Establezca el puntero actual en la nueva dirección de la entidad
		fseek(dataDictionary,currentAttributePointer, SEEK_SET);
		fwrite(&newAttributeDirection,sizeof(long),1,dataDictionary);
	}
	else
    {
		char currentAttributeName[50];
		// long nextEntityDirection;
		long nextHeaderPointer;
		bool sigClavePrim;	
		//Vaya a la ubicación de la entidad y lea sus datos
		fseek(dataDictionary,currentAttributeDirection,SEEK_SET);
		//Lea el nombre de la entidad en la posición actual
		fread(&currentAttributeName,sizeof(char),50,dataDictionary);
		nextHeaderPointer= ftell(dataDictionary) + sizeof(bool) + (sizeof(long) * 2);
		fread(&sigClavePrim,sizeof(bool),1,dataDictionary);
			
		if(clavePrim)
		{
			if(sigClavePrim == clavePrim)
			{
				printf("YA EXISTE UNA CLAVE PRIMARIA\n");
				return;
			}
				
			//Reasignar el primer puntero
			fseek(dataDictionary,currentAttributePointer,SEEK_SET);
			fwrite(&newAttributeDirection, sizeof(long),1,dataDictionary);
			// Reassign new entity pointer
			fseek(dataDictionary,newAttributeDirection + 50 + sizeof(bool) + (sizeof(long) * 2),SEEK_SET);
			fwrite(&currentAttributeDirection, sizeof(long),1,dataDictionary);
			return;
		}
		if(strcmp(currentAttributeName, newAttributeName) == 0)
		{
			printf("YA EXISTE ESE ATRIBUTO\n");
			return;
		}
		else
		{
		    //Compare los nombres de las entidades para determinar si la entidad actual debe estar antes de la nueva o no
		    if(strcmp(currentAttributeName, newAttributeName) < 0 || sigClavePrim || clavePrim){
		    	//La entidad actual es anterior a la nueva
		    	reorderAttributes(dataDictionary,nextHeaderPointer,newAttributeName,newAttributeDirection,0);
		    }
		    else
            {
		    	//Reasignar el primer puntero
		    	fseek(dataDictionary,currentAttributePointer,SEEK_SET);
			    fwrite(&newAttributeDirection, sizeof(long),1,dataDictionary);
		    	// Reassign new entity pointer
		    	fseek(dataDictionary,newAttributeDirection + 50 + sizeof(bool) + (sizeof(long) * 2),SEEK_SET);
			    fwrite(&currentAttributeDirection, sizeof(long),1,dataDictionary);
		    }
		}
	}
}

int eliminaAtributo(FILE *Diccionario, char nom[N], long cab) {
	rewind(Diccionario);
	if (!Diccionario) return 0;
	
	ATTRIBUTE atributo;
	long ant, ptr, ptrdir;
	
	// Leer la cabecera (dirección de la cabeza de la lista)
	fseek(Diccionario, cab, SEEK_SET);
	fread(&ptr, sizeof(long), 1, Diccionario);
	
	if (ptr == -1) {
		fclose(Diccionario);
		return 0; // Lista vacía
	}
	
	// Desplazarse a la primera entidad
	fseek(Diccionario, ptr, SEEK_SET);
	fread(atributo.name, N, 1, Diccionario);
	fread(&atributo.isPrimary, sizeof(bool), 1, Diccionario);
	fread(&atributo.type, sizeof(long), 1, Diccionario);
	fread(&atributo.size, sizeof(long), 1, Diccionario);
	ptrdir = ftell(Diccionario); // Dirección de la primera entidad
	fread(&ptr, sizeof(long), 1, Diccionario); // Obtener el puntero 'sig' de la primera entidad
	
	// Si la entidad a eliminar es la primera (cabeza de la lista)
	if (strcmp(atributo.name, nom) == 0) {
		// Actualizamos la cabeza de la lista para que apunte a la siguiente entidad
		fseek(Diccionario, cab, SEEK_SET);
		fwrite(&ptr, sizeof(long), 1, Diccionario); // Nueva cabeza de la lista
		return 1; // Eliminada con éxito
	}
	
	// Buscar la entidad a eliminar en el resto de la lista
	while (ptr != -1 && strcmp(atributo.name, nom) != 0) {
		ant = ptrdir;
		fseek(Diccionario, ptr, SEEK_SET);
		fread(atributo.name, N, 1, Diccionario);
		fread(&atributo.isPrimary, sizeof(bool), 1, Diccionario);
		fread(&atributo.type, sizeof(long), 1, Diccionario);
		fread(&atributo.size, sizeof(long), 1, Diccionario);
		ptrdir = ftell(Diccionario); // Dirección de la primera entidad
		fread(&ptr, sizeof(long), 1, Diccionario); // Obtener el puntero 'sig' de la primera entidad
	}
	
	// Si no se encontró la entidad, devolvemos 0
	if (ptr == -1 && strcmp(atributo.name, nom) != 0) {
		return 0;
	}
	
	// Ahora eliminamos la entidad: Actualizamos el puntero 'sig' de la entidad anterior
	fseek(Diccionario, ant, SEEK_SET); // Desplazarse a la entidad anterior
	fwrite(&ptr, sizeof(long), 1, Diccionario); // Actualizamos el puntero 'sig' para omitir la entidad eliminada
	
	
	return 1; // Eliminación exitosa
}

void modificaAtributo(FILE* dataDictionary,char nom[50], long cab)
{
	rewind(dataDictionary);
	long DirAtributo;
	ATTRIBUTE newAttribute;
	
	fseek(dataDictionary,cab,SEEK_SET);
	fread(&DirAtributo,sizeof(long),1,dataDictionary);
	if(DirAtributo == -1)
	{
		printf("NO HAY ATRIBUTOS");
		return;
	}
	
	fseek(dataDictionary,DirAtributo,SEEK_SET);
	fread(newAttribute.name, 50, 1, dataDictionary);
	fread(&newAttribute.isPrimary, sizeof(bool), 1, dataDictionary);
	fread(&newAttribute.type, sizeof(long), 1, dataDictionary);
	fread(&newAttribute.size, sizeof(long), 1, dataDictionary);
	fread(&DirAtributo, sizeof(long), 1, dataDictionary);
	while(DirAtributo != -1 && (strcmp(newAttribute.name, nom)) != 0)
	{
		fseek(dataDictionary,DirAtributo,SEEK_SET);
		fread(newAttribute.name, 50, 1, dataDictionary);
		fread(&newAttribute.isPrimary, sizeof(bool), 1, dataDictionary);
		fread(&newAttribute.type, sizeof(long), 1, dataDictionary);
		fread(&newAttribute.size, sizeof(long), 1, dataDictionary);
		fread(&DirAtributo, sizeof(long), 1, dataDictionary);
	}
	newAttribute.nextAtribute= vacio;
	if(DirAtributo == -1 && (strcmp(newAttribute.name, nom)) != 0)
	{
		printf("NO EXISTE ESE ATRIBUTO\n");
		return;
	}
	eliminaAtributo(dataDictionary,nom,cab);
	
	printf("NUEVO NOMBRE: ");
	scanf("%s",newAttribute.name);
	
	DirAtributo= appendAttribute(dataDictionary,newAttribute);
	reorderAttributes(dataDictionary,cab,newAttribute.name,DirAtributo,newAttribute.isPrimary);
}
